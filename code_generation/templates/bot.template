# -*- coding: utf-8 -*-
import json
import re

from datetime import timedelta, datetime
from DictObject import DictObject

from luckydonaldUtils.logger import logging
from luckydonaldUtils.encoding import unicode_type, to_unicode as u, to_native as n
from luckydonaldUtils.exceptions import assert_type_or_raise

from ..exceptions import TgApiServerException, TgApiParseException
from ..exceptions import TgApiTypeError, TgApiResponseException
from ..api_types.sendable.inline import InlineQueryResult
from ..api_types import from_array_list

from .base import BotBase

{% if is_asyncio %}
# async imports
from async_property import async_property
import httpx{#
#}{% else %}
# sync imports
import requests{#
#}{% endif %}{% from "macros.template" import for_type_list_of_full %}


__author__ = 'luckydonald'
__all__ = ["{% if is_asyncio %}AsyncBot{% else %}SyncBot{% endif %}", "Bot"]

logger = logging.getLogger(__name__)


class {% if is_asyncio %}AsyncBot{% else %}SyncBot{% endif %}(BotBase):
    {% if is_asyncio %}async {% endif %}def send_msg(self, *args, **kwargs):
        """ alias to :func:`send_message` """
        return self.send_message(*args, **kwargs)
    # end def send_msg

    {% if is_asyncio %}async {% endif %}def do(self, command, files=None, use_long_polling=False, request_timeout=None, **query):
        """
        Send a request to the api.

        If the bot is set to return the json objects, it will look like this:

        ```json
        {
            "ok": bool,
            "result": {...},
            # optionally present:
            "description": "human-readable description of the result",
            "error_code": int
        }
        ```

        :param command: The Url command parameter
        :type  command: str

        :param request_timeout: When the request should time out. Default: `None`
        :type  request_timeout: int

        :param files: if it needs to send files.

        :param use_long_polling: if it should use long polling. Default: `False`
                                (see http://docs.python-requests.org/en/latest/api/#requests.Response.iter_content)
        :type  use_long_polling: bool

        :param query: all the other `**kwargs` will get json encoded.

        :return: The json response from the server, or, if `self.return_python_objects` is `True`, a parsed return type.
        :rtype:  DictObject.DictObject | pytgbot.api_types.receivable.Receivable
        """
        {% if is_asyncio %}import httpx
        {% else %}import requests
        {% endif %}

        url, params = self._prepare_request(command, query)
        r = requests.post(url, params=params, files=files, stream=use_long_polling,
                          verify=True,  # No self signed certificates. Telegram should be trustworthy anyway...
                          timeout=request_timeout)
        return self._postprocess_request(r)
    # end def do

    {% if is_asyncio %}async {% endif %}def _do_fileupload(self, file_param_name, value, _command=None, **kwargs):
        """
        :param file_param_name: For what field the file should be uploaded.
        :type  file_param_name: str

        :param value: File to send. You can either pass a file_id as String to resend a file
                      file that is already on the Telegram servers, or upload a new file,
                      specifying the file path as :class:`pytgbot.api_types.sendable.files.InputFile`.
        :type  value: pytgbot.api_types.sendable.files.InputFile | str

        :param _command: Overwrite the sended command.
                         Default is to convert `file_param_name` to camel case (`"voice_note"` -> `"sendVoiceNote"`)

        :param kwargs: will get json encoded.

        :return: The json response from the server, or, if `self.return_python_objects` is `True`, a parsed return type.
        :rtype:  DictObject.DictObject | pytgbot.api_types.receivable.Receivable

        :raises TgApiTypeError, TgApiParseException, TgApiServerException: Everything from :meth:`Bot.do`, and :class:`TgApiTypeError`
        """
        from ..api_types.sendable.files import InputFile
        from luckydonaldUtils.encoding import unicode_type
        from luckydonaldUtils.encoding import to_native as n

        if isinstance(value, str):
            kwargs[file_param_name] = str(value)
        elif isinstance(value, unicode_type):
            kwargs[file_param_name] = n(value)
        elif isinstance(value, InputFile):
            kwargs["files"] = value.get_request_files(file_param_name)
        else:
            raise TgApiTypeError("Parameter {key} is not type (str, {text_type}, {input_file_type}), but type {type}".format(
                key=file_param_name, type=type(value), input_file_type=InputFile, text_type=unicode_type))
        # end if
        if not _command:
            # command as camelCase  # "voice_note" -> "sendVoiceNote"  # https://stackoverflow.com/a/10984923/3423324
            command = re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), "send_" + file_param_name)
        else:
            command = _command
        # end def
        return {% if is_asyncio %}await {% endif %}self.do(command, **kwargs)
    # end def _do_fileupload

    # start of generated functions
    {% for function in functions %}
    {% if is_asyncio %}async {% endif %}def {{ function.name }}(self{% for variable in function.variables %}, {{ variable.name }}{% if variable.optional %}={% if variable.default %}{{ variable.default }}}{% else %}None{% endif %}{% endif %}{% endfor %}):
        """
        Internal function for making the request to the API's {{ function.api_name }} endpoint.

        {% if function.parameters %}
        Parameters:
        {% for param in function.parameters %}
        :param {{ param.name }}: {{ param.description }}
        :type  {{ param.name }}: {{ for_type_list_of_full(param) }}
        {% endfor %}
        {% endif %}
        {% if function.keywords -%}
        Optional keyword parameters:
        {% for keyword in function.keywords %}
        :param {{ keyword.name }}: {{ keyword.description }}
        :type  {{ keyword.name }}: {{ for_type_list_of_full(keyword) }}
        {% endfor %}
        {% endif -%}


        Returns:

        :return: {{ function.returns.description }}
        :rtype:  {{ for_type_list_of_full(function.returns) }}
        """
        result = {% if is_asyncio %}await {% endif %}self._{{ function.name }}__make_request({% for variable in function.variables %}{{ variable.name }}={{ variable.name }}{% if not loop.last %}, {% endif %}{% endfor %})
        return self._{{ function.name }}__process_result(result)
    # end def {{ function.name }}{#
    #}{% if not loop.last %}{# extra linebreak #}
    {% endif %}{#
    #}{% endfor %}
    # end of generated functions
# end class Bot

# allow importing the bot as `pytgbot.bot.{% if is_asyncio %}a{% endif %}syncrounous.Bot`.
Bot = {% if is_asyncio %}AsyncBot{% else %}SyncBot{% endif %}
